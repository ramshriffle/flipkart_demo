c
product
subject.body
c
subject.body
params
c
subject.body
params
c
JSON.parse(subject.body)
subject.body
params
c
Product.find_by(id: 0)
Product.find_by(id: params[:id])
c
params
subject.body
product
user
c
@current_user
c
user
c
user
c
subject.body
JSON.parse(subject.body)
c
JSON.parse(subject.body)
c
JSON.parse(subject.body)
c
JSON.parse(subject.body)
product
c
product
c
JSON.parse(subject.body)
params
c
 expect(subject).to have_http_status(401)
bearer_token
c
bearer_token
c
bearer_token
c
bearer_token
c
bearer_token
c
expect(JSON.parse(subject.body)).to eq({"error"=>"Invalid token"})
 expect(subject).to have_http_status(401)
bearer_token
c
expect( JSON.parse(subject.body)).to eq("message"=>"Account deleted successfully!!")
expect(subject).to have_http_status(200)
JSON.parse(subject.body)
c
JSON.parse(subject.body)
c
JSON.parse(subject.body)
c
JSON.parse(subject.body)
c
n
nn
n
c
n
nn
n
@current_user
@current_user.destroy
@current_user
c
expect(subject).to have_http_status(200)
user
params
c
subject.body
c
subject.body
JSON.parse(subject.body)
user
c
expect( JSON.parse(subject.body)).to eq("errors"=>["Name can't be blank"])
expect(subject).to have_http_status(422)
c
JSON.parse(subject.body)
c
JSON.parse(subject.body)
c
JSON.parse(subject.body)
c
JSON.parse(subject.body)
c
JSON.parse(subject.body)
expect(JSON.parse(subject.body)).to eq("id"=> user.id, "name"=> 'ram', "username"=>user.username, "email"=>user.email, "mobile_no"=>user.mobile_no, "type"=>user.type, "profile_picture"=>nil )
 expect(subject).to have_http_status(200)
c
JSON.parse(subject.body)
c
user_params
c
user_params
c
user_params
c
params
subject.body
user
c
user
@user
c
subject.body
c
subject.body
c
subject.body
c
params
c
params
c
bearer_token
subject.body
c
@user
c
@user
c
subject.body
c
subject.body
c
user
c
@user
c
@product
c
expect( (@user.otp_sent_at + 5.seconds) > Time.now.utc).to eq "false"c
expect( (@user.otp_sent_at + 5.seconds) > Time.now.utc).to eq "false"
@user
n
@user
@user.otp_sent_at
otp_sent_at
c
@user.otp_sent_at
expect( (@user.otp_sent_at + 5.second) > Time.now.utc).to eq "false"
c
(self.otp_sent_at + 5.second) > Time.now.utc
c
(self.otp_sent_at + 1.hours) > Time.now.utc
c
otp_sent_at
(otp_sent_at + 1.hours) > Time.now.utc
c
(otp_sent_at + 1.hours) > Time.now.utc
n
@user.otp_sent_at + 1.hours
user.otp_sent_at + 1.hours
@user.otp_sent_at
c
expect( (@user.otp_sent_at + 1.hours) > Time.now.utc).to eq "false"
c
(otp_sent_at + 1.hours) > Time.now.utc
c
@user
c
self
c
self
n
self
n
self
c
@order_item
c
n
item_price = product.price * quantity
quantity
product.price
c
@user.generate_otp
c
@user
c
@user
c
@user
c
@user
c
exit
c
user
subject
subject.body
expect(JSON.parse(subject.body))
expect(JSON.parse(subject.body)).to eq({"error"=>"Invalid token"})
c
token
bearer_token
expect(subject).to have_http_status(401)
subject.body
c
JSON.parse(subject.body)
subject.body
user.id
user
subject
c
JSON.parse(subject.body)
c
JSON.parse(subject.body)
subject.body
c
subject.body
JSON.parse(subject.body)
expect(JSON.parse(subject.body)).to eq("error"=>"token is invalid or expired")
expect(subject).to have_http_status(401)
c
subject.body
c
expect(JSON.parse(subject.body)).to eq({ 'error' => 'token is invalid or expired' })
c
subject.body
bearer_token
token
c
JSON.parse(subject.body)
subject.body
product
c
product
subject.body
subject
bearer_token
token
c
it { should belong_to(:user) }
should belong_to(:user)
user
c
expect(@order_item.quantity).to_not be > -1
@order_item.quantity
 @order_item.quantity = -1
@order_item.quantity
