c
c\
c
subject
c
subject
c
subject.body
c
self.attributes.merge({ product_name: product.title })
self.attributes.merge({ product_name: product.name })
self.attributes.except({'updated_at'})
self.attributes.except{'updated_at'}
a
a=self.attributes.except{:updated_at}
self.attributes.except{:updated_at}
self.attributes.merge{ product_name :product.name }
self.attributes.merge{ product_name: product.name }
self.attributes.merge{ product_name = product.name }
   22:     }
   21:       product_name = product.title
self.attributes.merge{
Order.new.attributes
Order.attributes
self.attributes
c
Order.attribute
Order.attributes
params[:query]
c
product
JSON.parse(subject.body)
c
expect(JSON.parse(subject.body)).to eq([])
JSON.parse(subject.body)
c
params[:query]
n
c
subject.body
params
subject
c
self.__elasticsearch__.search(query)
query
c
n
b
n
products
n
 Product.search(params[:query])
c
 Product.search(params[:query])
params[:query]
c
params[:query]
c
n
token
n
c
n
c
subject.body
c
subject.body
c
subject.body
c
subject.body
c
subject.body
c
subject.body
c
expect(subject).to have_http_status(201)
c
params
c
n
c
n
c
n
c
n
@user = params[:user]
c
n
@order
n
c
n
c
n
api_products
n
c
n
api_products
n
c
n
c
n
@product = @current_user.products.find_by_id(params[:id])
c
n
 cart_item = @current_user.cart_items.find_by_product_id(params[:product_id])
c
n
Order.where(product: product).sum(:quantity)
c
order.save
order
order = @current_user.orders.new(order_params)
c
n
c
n
order_params
@current_user
c
n
decoded
n
c
@current_user
@current_user = User.find(decoded[:user_id])
@current_user
n
c
user
c
Order.find_by_id(params[:id])
c
n
request.headers[:token]
params[:token]
params[:token
token
c
@order.update(params[:status])
n
 params[:status] == 'cancel'
c
n
@order
n
c
 @current_user.orders.find_by_id(params[:id])
c
@current_user.orders
@current_user
c
n
c
n
c
AdvanceOrderWorker.perform_async(@current_user.id, order_params)
c
order_params
@current_user.id
c
n
c
expect do delete :destroy, params: { id: product.id } end.to change(Product, :count).by(0)
c
expect do subject end.to change(Product, :count).by(0)
expect(Product.count).to eq(0)
expect do subject end.to change(Product, :count).by(0)
c
expect do subject end.to change(Product, :count).by(0)
expect(JSON.parse(subject.body)).to eq('message' => 'Product delete successfully')
expect(subject).to have_http_status(200)
Product.count
expect do subject end.to change(Product, :count).by(0)
expect(subject).to change(Product, :count).by(0)
              subject
expect do
Product.count
c
Product.count
c
Product.count
c
Product.count
c
User.count
c
User.count
c
User.count
c
Product.count
c
Product.count
c
Product.count
c
Product.count
c
Product.count
c
Product.count
c
Product.count
c
expect(subject).to change(Product, :count).by(0)
Product.count
c
subject.body
expect do subject end.to change(Product, :count).by(0)
expect do subject end
end
subject
expect
            end.to change(Product, :count).by(0)expec
              subject
 expect do
c
            end.to change(Product, :count).by(0)c
              subject
 expect do
   209:             end.to change(Product, :count).by(0)
   208:               subject
 expect do
subject
subjec
c
Product.count
c
   209:             end.to change(Product, :count).by(0)c
   208:               delete :destroy, params: {id: product.id}
expect do
c
Product.count
c
Product.count
c
Product.count
c
Product.count
   208:               delete :destroy, params: {id: product.id}
expect do
Product.count
c
   209:             end.to change(Product, :count).by(-1)c
   208:               delete :destroy, params: {id: product.id}
expect do
 expect(delete :destroy, params: {id: product.id} ).to change(Product, :count).by(-1)
c
expect(delete: destroy, params: {id: product.id} ).to change(Product, :count).by(-1)
product
c
