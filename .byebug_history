c
user
c
Order.find_by_id(params[:id])
c
n
request.headers[:token]
params[:token]
params[:token
token
c
@order.update(params[:status])
n
 params[:status] == 'cancel'
c
n
@order
n
c
 @current_user.orders.find_by_id(params[:id])
c
@current_user.orders
@current_user
c
n
c
n
c
AdvanceOrderWorker.perform_async(@current_user.id, order_params)
c
order_params
@current_user.id
c
n
c
expect do delete :destroy, params: { id: product.id } end.to change(Product, :count).by(0)
c
expect do subject end.to change(Product, :count).by(0)
expect(Product.count).to eq(0)
expect do subject end.to change(Product, :count).by(0)
c
expect do subject end.to change(Product, :count).by(0)
expect(JSON.parse(subject.body)).to eq('message' => 'Product delete successfully')
expect(subject).to have_http_status(200)
Product.count
expect do subject end.to change(Product, :count).by(0)
expect(subject).to change(Product, :count).by(0)
              subject
expect do
Product.count
c
Product.count
c
Product.count
c
Product.count
c
User.count
c
User.count
c
User.count
c
Product.count
c
Product.count
c
Product.count
c
Product.count
c
Product.count
c
Product.count
c
Product.count
c
expect(subject).to change(Product, :count).by(0)
Product.count
c
subject.body
expect do subject end.to change(Product, :count).by(0)
expect do subject end
end
subject
expect
            end.to change(Product, :count).by(0)expec
              subject
 expect do
c
            end.to change(Product, :count).by(0)c
              subject
 expect do
   209:             end.to change(Product, :count).by(0)
   208:               subject
 expect do
subject
subjec
c
Product.count
c
   209:             end.to change(Product, :count).by(0)c
   208:               delete :destroy, params: {id: product.id}
expect do
c
Product.count
c
Product.count
c
Product.count
c
Product.count
   208:               delete :destroy, params: {id: product.id}
expect do
Product.count
c
   209:             end.to change(Product, :count).by(-1)c
   208:               delete :destroy, params: {id: product.id}
expect do
 expect(delete :destroy, params: {id: product.id} ).to change(Product, :count).by(-1)
c
expect(delete: destroy, params: {id: product.id} ).to change(Product, :count).by(-1)
product
c
subject.body
c
n
@current_user.cart_items
CartItem
cart_items
@current_user
c
subject.body
c
subject.body
c
subject.body
c
item
product
n
c
n
api_products
n
c
n
c
api_products
n
c
expect(subject).to change(User, count).by(-1)
c
subject.body
c
subject.stacktrace
subject.body
c
expect(JSON.parse(subject.body)).to eq({"message"=>"Address not found"})
c
JSON.parse(subject.body)
c
params
c
n
c
JSON.parse(subject.body)
subject.body
c
subject.body
c
params
c
expect(response).to have_http_status(:not_found)
c
response.body
respose.body
subject.body
c
subject.body
c
subject.body
c
subject.body
c
subject.body
params
c
user
product
product.id
params
subject.body
c
JSON.parse(subject.body)
subject.body
c
expect(subject.body).to eq('otp successfully generated for login')
 expect(subject).to have_http_status(200)
c
n
user
n
c
user
c
params
c
n
User.find_by(otp: params[:otp])
params[:otp]
c
(otp_sent_at + 1.hour) > Time.now.utc
n
User.find_by(otp: params[:otp])
c
user.present?
User.find_by(otp: params[:otp])
params[:otp]
User.find_by(otp: params[:otp])
c
user
c
User.find_by(otp: params[:otp])
params[:otp]
user.present?
n
c
n
c
v
c
expect(JSON.parse(subject.body)).to eq({"error"=>"otp is not valid or expired. try again"})
c
JSON.parse(subject.body)c
JSON.parse(subject.body)
c
n
c
JSON.parse(subject.body)
subject.body
c
subject.body
c
n
c
n
c
n
c
n
c
JSON.parse(subject.body)
subject.body
c
subject.body
